/******************************************************************************
** Project: P2PAS server/client
**
** Description: Communication interface to access the devices.
******************************************************************************/
#ifndef __PASCOMMUNICATIONINTERFACE_H__
#define __PASCOMMUNICATIONINTERFACE_H__

#include <map>
#include <string>
#include <utility>
#include <vector>

#include "uabase/statuscode.h"
#include "uabase/uaarraytemplates.h"
#include "uabase/uabase.h"
#include "uabase/uastring.h"

#include "common/alignment/device.hpp"
#include "common/opcua/pascominterfacecommon.hpp"

#include "client/clienthelper.hpp"
#include "client/utilities/configuration.hpp"


class PasController;

class PasCommunicationInterface: public PasComInterfaceCommon
{
    UA_DISABLE_COPY(PasCommunicationInterface);
public:

    /* construction / destruction */
    PasCommunicationInterface();

    ~PasCommunicationInterface() override;

    UaStatus initialize() override;

    void setConfiguration(std::shared_ptr<Configuration> pConfiguration) {
        m_pConfiguration = std::move(pConfiguration);
    }

    const Device::Identity
    addDevice(const std::shared_ptr<Client> &pClient, OpcUa_UInt32 deviceType, const Device::Identity &identity);

    OpcUa_Int32 getDevices(OpcUa_UInt32 deviceType);

    UaStatus getDeviceConfig(
        OpcUa_UInt32 type,
        OpcUa_UInt32 deviceIndex,
        UaString &sName,
        Device::Identity &identity);

    /* overloaded getDeviceConfig() for when you only want the identity */
    UaStatus getDeviceConfig(
        OpcUa_UInt32 type,
        OpcUa_UInt32 deviceIndex,
        Device::Identity &identity);

    /* Get device status and data */
    UaStatus getDeviceState(
        OpcUa_UInt32 type,
        const Device::Identity &identity,
        Device::ErrorState &state) override;

    UaStatus getDeviceData(
        OpcUa_UInt32 type,
        const Device::Identity &identity,
        OpcUa_UInt32 offset,
        UaVariant &value) override;

    /* Set device status and data*/
    UaStatus setDeviceState(
        OpcUa_UInt32 type,
        const Device::Identity &identity,
        Device::ErrorState state) override;

    UaStatus setDeviceData(
        OpcUa_UInt32 type,
        const Device::Identity &identity,
        OpcUa_UInt32 offset,
        UaVariant value) override;

    /* operate a device -- run a method */
    UaStatus operateDevice(OpcUa_UInt32 type, const Device::Identity &identity,
                           OpcUa_UInt32 offset = 0,
                           const UaVariantArray &args = UaVariantArray()) override;

    std::shared_ptr<PasController> getDeviceFromId(OpcUa_UInt32 type, const Device::Identity &identity);

    static std::map<OpcUa_UInt32, std::string> deviceTypeNames;

private:

    std::shared_ptr<Configuration> m_pConfiguration;

    // The following are internal maps generated by the communication interface and needed
    // to properly map individual hardware device to its virtual device
    //
    // maps DeviceType -> VectorOfDevices
    std::map<OpcUa_UInt32, std::vector<std::shared_ptr<PasController>>> m_pControllers;
    //
    // maps from id to internal array indices: DeviceType -> {Identity -> arrayIdx }
    std::map<OpcUa_UInt32, std::map<Device::Identity, int> > m_DeviceIdentityMap;

    OpcUa_Boolean m_stop;
};

#endif // #ifndef __PASCOMMUNICATIONINTERFACE_H__
