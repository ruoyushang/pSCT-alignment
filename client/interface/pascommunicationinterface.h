/******************************************************************************
** Project: P2PAS server/client
**
** Description: Communication interface to access the devices.
******************************************************************************/
#ifndef __PASCOMMUNICATIONINTERFACE_H__
#define __PASCOMMUNICATIONINTERFACE_H__

#include "uabase.h"
#include "uastring.h"
#include "statuscode.h"
#include "uaarraytemplates.h"
#include "pascominterfacecommon.h"
#include "components.h"
#include <vector>
#include <map>
#include <string>
#include <utility> // pair

#include "common/alignment/device.hpp"

struct Identity;
class Client;
class PasController;
class Configuration;

class PasCommunicationInterface: public PasComInterfaceCommon
{
    UA_DISABLE_COPY(PasCommunicationInterface);
public:

    /* construction / destruction */
    PasCommunicationInterface();
    virtual ~PasCommunicationInterface();

    virtual UaStatusCode Initialize();

    void setConfiguration(Configuration *pConfiguration) {m_pConfiguration = pConfiguration;}

    const Identity addDevice(Client *pClient, OpcUa_UInt32 deviceType, const Identity& identity);

    OpcUa_Int32 getDevices(OpcUa_UInt32 deviceType);

    UaStatusCode getDeviceConfig(
        OpcUa_UInt32 type,
        OpcUa_UInt32 deviceIndex,
        UaString& sName,
        Identity& identity);

    /* overloaded getDeviceConfig() for when you only want the identity */
    UaStatusCode getDeviceConfig(
        OpcUa_UInt32 type,
        OpcUa_UInt32 deviceIndex,
        Identity& identity);

    /* Get device status and data */
    UaStatus getDeviceState(
            OpcUa_UInt32 type,
            const Identity &identity,
            Device::DeviceState &state);

    UaStatus getDeviceData(
            OpcUa_UInt32 type,
            const Identity &identity,
            OpcUa_UInt32 offset,
            UaVariant &value);

    /* Set device status and data*/
    UaStatus setDeviceState(
            OpcUa_UInt32 type,
            const Identity &identity,
            Device::DeviceState state);

    UaStatus setDeviceData(
        OpcUa_UInt32 type,
        const Identity& identity,
        OpcUa_UInt32 offset,
        UaVariant value);

    /* operate a device -- run a method */
    UaStatus operateDevice(OpcUa_UInt32 type, const Identity &identity,
                           OpcUa_UInt32 offset = 0,
                           const UaVariantArray &args = UaVariantArray());

    PasController* getDeviceFromId(OpcUa_UInt32 type, const Identity& identity);

    static std::map<OpcUa_UInt32, std::string> deviceTypeNames;

private:

    Configuration *m_pConfiguration;

    // The following are internal maps generated by the communication interface and needed
    // to properly map individual hardware device to its virtual device
    //
    // maps DeviceType -> VectorOfDevices
    std::map< OpcUa_UInt32, std::vector<PasController *> > m_pControllers;
    //
    // maps from id to internal array indices: DeviceType -> {Identity -> arrayIdx }
    std::map< OpcUa_UInt32, std::map<Identity, int> > m_DeviceIdentityMap;

    OpcUa_Boolean m_stop;
};

#endif // #ifndef __PASCOMMUNICATIONINTERFACE_H__
